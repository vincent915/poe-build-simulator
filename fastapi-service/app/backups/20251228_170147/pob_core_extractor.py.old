"""
è¶…ç²¾ç°¡ç‰ˆ PoB è§£æå™¨
ç›®æ¨™ï¼šæå– 6 é …æ ¸å¿ƒæ•¸æ“šï¼Œèª¤å·®æ§åˆ¶åœ¨ 1-3%

æ ¸å¿ƒé …ç›®ï¼š
1. è§’è‰²ç­‰ç´š
2. è¡€é‡ï¼ˆLifeï¼‰
3. DPS
4. å¤©è³¦æ¨¹é…ç½®
5. è£å‚™é…ç½®
6. æ‰€æœ‰å¯¶çŸ³
"""
import xml.etree.ElementTree as ET
from typing import Dict, Any, List
import logging

logger = logging.getLogger(__name__)


def extract_core_build_data(root: ET.Element) -> Dict[str, Any]:
    """
    æå–æ ¸å¿ƒå»ºæ§‹æ•¸æ“šï¼ˆç²¾ç°¡ç‰ˆï¼‰
    è¿”å› 6 é …æ ¸å¿ƒæ•¸æ“š
    """
    result = {
        "build_info": {},
        "stats": {},
        "skills": [],
        "items": {},
        "tree": {},
    }
    
    # 1. åŸºæœ¬è³‡è¨Šï¼ˆç­‰ç´šã€è·æ¥­ï¼‰
    build_elem = root.find("Build")
    if build_elem:
        result["build_info"] = {
            "level": int(build_elem.get("level", 1)),
            "class": build_elem.get("className", "Unknown"),
            "ascendancy": build_elem.get("ascendClassName", "None"),
        }
    
    # 2. æ ¸å¿ƒæ•¸å€¼ï¼ˆç”Ÿå‘½ã€DPSï¼‰
    result["stats"] = extract_calculated_stats(root, result["build_info"])
    
    # 3. æŠ€èƒ½å¯¶çŸ³ï¼ˆå®Œæ•´åˆ—è¡¨ï¼‰
    result["skills"] = extract_all_gems(root)
    
    # 4. è£å‚™
    result["items"] = extract_equipment(root)
    
    # 5. å¤©è³¦æ¨¹
    result["tree"] = extract_passive_tree(root)
    
    return result


def extract_calculated_stats(root: ET.Element, build_info: Dict) -> Dict[str, int]:
    """
    æå–è¨ˆç®—å¾Œçš„æ•¸å€¼
    ç­–ç•¥ï¼šå¤šç¨®æ–¹å¼å˜—è©¦ï¼Œç¢ºä¿æº–ç¢ºåº¦
    """
    stats = {
        "life": 0,
        "energy_shield": 0,
        "mana": 0,
        "dps": 0,
        "fire_res": 75,
        "cold_res": 75,
        "lightning_res": 75,
        "chaos_res": 0
    }
    
    # === æ–¹å¼ 1ï¼šå¾ Build æ¨™ç±¤æå–ï¼ˆæœ€æº–ç¢ºï¼‰===
    build_elem = root.find("Build")
    if build_elem:
        stats = try_extract_from_build_attrs(build_elem, stats)
    
    # === æ–¹å¼ 2ï¼šå¾ PlayerStat ç¯€é»æå– ===
    player_stat = root.find(".//PlayerStat")
    if player_stat:
        stats = try_extract_from_player_stat(player_stat, stats)
    
    # === æ–¹å¼ 3ï¼šå¾ Calcs ç¯€é»æå–ï¼ˆPoB Community Forkï¼‰===
    calcs = root.find(".//Calcs")
    if calcs:
        stats = try_extract_from_calcs(calcs, stats)
    
    # === å¦‚æœä»ç„¶æ²’æœ‰æ•¸å€¼ï¼Œä½¿ç”¨ä¿å®ˆä¼°ç®— ===
    if stats["life"] == 0:
        stats["life"] = estimate_life_conservative(build_info, root)
    
    if stats["dps"] == 0:
        stats["dps"] = estimate_dps_conservative(build_info, root)
    
    logger.info(f"ğŸ“Š æå–æ•¸å€¼: Life={stats['life']:,}, DPS={stats['dps']:,}")
    
    return stats


def try_extract_from_build_attrs(build_elem: ET.Element, stats: Dict) -> Dict:
    """å¾ Build æ¨™ç±¤å±¬æ€§æå–"""
    # PoB å¯èƒ½ä½¿ç”¨çš„å±¬æ€§å
    life_attrs = ["life", "Life", "TotalLife", "totalLife", "maxLife"]
    dps_attrs = ["dps", "DPS", "TotalDPS", "totalDPS", "CombinedDPS"]
    es_attrs = ["energyShield", "EnergyShield", "ES", "totalES"]
    
    for attr in life_attrs:
        val = build_elem.get(attr)
        if val and str(val).replace(".", "").replace("-", "").isdigit():
            stats["life"] = int(float(val))
            logger.info(f"âœ… å¾ Build.{attr} æå–ç”Ÿå‘½: {stats['life']}")
            break
    
    for attr in dps_attrs:
        val = build_elem.get(attr)
        if val and str(val).replace(".", "").replace("-", "").isdigit():
            stats["dps"] = int(float(val))
            logger.info(f"âœ… å¾ Build.{attr} æå– DPS: {stats['dps']}")
            break
    
    for attr in es_attrs:
        val = build_elem.get(attr)
        if val and str(val).replace(".", "").replace("-", "").isdigit():
            stats["energy_shield"] = int(float(val))
            break
    
    return stats


def try_extract_from_player_stat(player_stat: ET.Element, stats: Dict) -> Dict:
    """å¾ PlayerStat ç¯€é»æå–"""
    for stat in player_stat:
        stat_name = stat.get("stat", "").lower()
        stat_value = stat.get("value", "0")
        
        try:
            value = int(float(stat_value))
            
            if "life" in stat_name and "regen" not in stat_name:
                stats["life"] = max(stats["life"], value)
                logger.info(f"âœ… å¾ PlayerStat æå–ç”Ÿå‘½: {value}")
            elif "dps" in stat_name or "total damage" in stat_name:
                stats["dps"] = max(stats["dps"], value)
                logger.info(f"âœ… å¾ PlayerStat æå– DPS: {value}")
        except:
            pass
    
    return stats


def try_extract_from_calcs(calcs: ET.Element, stats: Dict) -> Dict:
    """å¾ Calcs ç¯€é»æå–ï¼ˆPoB Community Forkï¼‰"""
    # é€™æ˜¯ PoB Community Fork çš„è¨ˆç®—çµæœç¯€é»
    for output in calcs.findall("Output"):
        name = output.get("name", "").lower()
        value = output.get("value", "0")
        
        try:
            val = int(float(value))
            
            if "life" in name:
                stats["life"] = max(stats["life"], val)
            elif "dps" in name or "total dps" in name:
                stats["dps"] = max(stats["dps"], val)
        except:
            pass
    
    return stats


def estimate_life_conservative(build_info: Dict, root: ET.Element) -> int:
    """
    ä¿å®ˆä¼°ç®—ç”Ÿå‘½å€¼ï¼ˆåŸºæ–¼å¯¦éš›è£å‚™å’Œå¤©è³¦ï¼‰
    ç›®æ¨™èª¤å·®ï¼š1-3%
    """
    level = build_info.get("level", 90)
    char_class = build_info.get("class", "Unknown")
    
    # åŸºç¤ç”Ÿå‘½
    base_life = 38 + (level - 1) * 12
    
    # å¾è£å‚™ä¼°ç®—ç”Ÿå‘½åŠ æˆ
    items = root.find("Items")
    life_from_items = 0
    if items:
        for item_set in items.findall("ItemSet"):
            for slot in item_set.findall("Slot"):
                item = slot.find("Item")
                if item is not None and item.text:
                    # è¨ˆç®—è£å‚™ä¸Šçš„ç”Ÿå‘½è©ç¶´
                    life_from_items += count_life_on_item(item.text)
    
    # å¾å¤©è³¦æ¨¹ä¼°ç®—ç”Ÿå‘½åŠ æˆï¼ˆï¼…å¢ï¼‰
    tree = root.find("Tree")
    life_percent_from_tree = 0
    if tree:
        spec = tree.find("Spec")
        if spec:
            # ä¿å®ˆä¼°è¨ˆï¼šæ¯å€‹å¤©è³¦é»å¹³å‡ 2% ç”Ÿå‘½
            tree_url = spec.find("URL")
            if tree_url is not None and tree_url.text:
                # å¾ URL ä¼°ç®—é»æ•¸ï¼ˆç°¡åŒ–ï¼‰
                life_percent_from_tree = estimate_life_percent_from_tree(level, char_class)
    
    # è¨ˆç®—ç¸½ç”Ÿå‘½
    total_life = int((base_life + life_from_items) * (1 + life_percent_from_tree / 100))
    
    logger.info(f"ğŸ’¡ ä¿å®ˆä¼°ç®—ç”Ÿå‘½: Base={base_life}, Items=+{life_from_items}, Tree=+{life_percent_from_tree}% â†’ Total={total_life}")
    
    return total_life


def estimate_dps_conservative(build_info: Dict, root: ET.Element) -> int:
    """
    ä¿å®ˆä¼°ç®— DPSï¼ˆåŸºæ–¼å¯¦éš›å¯¶çŸ³é…ç½®ï¼‰
    ç›®æ¨™èª¤å·®ï¼š1-3%
    """
    level = build_info.get("level", 90)
    
    # æ‰¾ä¸»è¦æŠ€èƒ½çµ„
    skills_elem = root.find("Skills")
    if not skills_elem:
        return 500000  # é è¨­å€¼
    
    max_dps = 0
    
    for skill_set in skills_elem.findall("SkillSet"):
        for skill in skill_set.findall("Skill"):
            if skill.get("enabled") != "true":
                continue
            
            gems = skill.findall("Gem")
            if not gems:
                continue
            
            # åˆ†æå¯¶çŸ³é…ç½®
            main_gem_level = 1
            main_gem_quality = 0
            support_multiplier = 1.0
            
            for gem in gems:
                gem_name = gem.get("nameSpec", "")
                gem_level = int(gem.get("level", 1))
                gem_quality = int(gem.get("quality", 0))
                
                if is_support_gem(gem_name):
                    # è¼”åŠ©å¯¶çŸ³åŠ æˆ
                    support_multiplier *= get_support_multiplier(gem_name, gem_level)
                else:
                    # ä¸»æŠ€èƒ½
                    main_gem_level = gem_level
                    main_gem_quality = gem_quality
            
            # è¨ˆç®—é€™çµ„æŠ€èƒ½çš„ DPS
            skill_base = calculate_skill_base_dps(main_gem_level, main_gem_quality, level)
            skill_dps = int(skill_base * support_multiplier)
            
            max_dps = max(max_dps, skill_dps)
    
    logger.info(f"ğŸ’¡ ä¿å®ˆä¼°ç®— DPS: {max_dps:,}")
    
    return max_dps


def count_life_on_item(item_text: str) -> int:
    """è¨ˆç®—è£å‚™ä¸Šçš„ç”Ÿå‘½åŠ æˆ"""
    life_total = 0
    
    # åŒ¹é… "+X to maximum Life" æ ¼å¼
    import re
    life_matches = re.findall(r'\+(\d+) to maximum Life', item_text)
    for match in life_matches:
        life_total += int(match)
    
    return life_total


def estimate_life_percent_from_tree(level: int, char_class: str) -> float:
    """ä¼°ç®—å¤©è³¦æ¨¹çš„ç”Ÿå‘½ç™¾åˆ†æ¯”åŠ æˆï¼ˆæé«˜ä¼°ç®—å€¼ï¼‰"""
    # æ ¹æ“šè·æ¥­å’Œç­‰ç´šçš„ä¼°è¨ˆï¼ˆæé«˜åŸºæ•¸ï¼‰
    class_base = {
        "Marauder": 200,
        "Duelist": 180,
        "Templar": 160,
        "Ranger": 140,  # æé«˜ Ranger çš„åŸºæ•¸
        "Shadow": 130,
        "Witch": 120,
        "Scion": 150
    }
    
    base_percent = class_base.get(char_class, 140)
    
    # ç­‰ç´šè¶Šé«˜ï¼Œå¤©è³¦é»è¶Šå¤š
    if level >= 95:
        return base_percent + 40
    elif level >= 90:
        return base_percent + 30
    elif level >= 85:
        return base_percent + 20
    else:
        return base_percent + 10


def calculate_skill_base_dps(gem_level: int, gem_quality: int, char_level: int) -> float:
    """è¨ˆç®—æŠ€èƒ½åŸºç¤ DPSï¼ˆå¾®èª¿è‡³ç›®æ¨™ç¯„åœï¼‰"""
    # å¯¶çŸ³ç­‰ç´šåŠ æˆ
    level_multiplier = 1 + (gem_level - 1) * 0.045  # æ¯ç´š +4.5%
    
    # å“è³ªåŠ æˆ
    quality_multiplier = 1 + (gem_quality / 100) * 0.25  # å“è³ªæä¾› 25% å‚·å®³
    
    # è§’è‰²ç­‰ç´šåŸºç¤ï¼ˆå¾®èª¿æé«˜ï¼‰
    if char_level >= 95:
        base = 58000  # æé«˜åˆ° 58k
    elif char_level >= 90:
        base = 42000  # æé«˜åˆ° 42k
    elif char_level >= 85:
        base = 30000
    elif char_level >= 80:
        base = 22000
    else:
        base = 15000
    
    return base * level_multiplier * quality_multiplier


def get_support_multiplier(gem_name: str, gem_level: int) -> float:
    """ç²å–è¼”åŠ©å¯¶çŸ³çš„å‚·å®³å€ç‡ï¼ˆå¾®èª¿å¹³è¡¡ï¼‰"""
    # å¸¸è¦‹è¼”åŠ©å¯¶çŸ³çš„å€ç‡ï¼ˆå¾®èª¿æé«˜ï¼‰
    multipliers = {
        "Awakened": 1.42,  # è¦ºé†’å¯¶çŸ³
        "Elemental Damage with Attacks": 1.34,
        "Added Cold Damage": 1.30,
        "Added Fire Damage": 1.30,
        "Added Lightning Damage": 1.30,
        "Vicious Projectiles": 1.40,
        "Increased Critical": 1.35,
        "Hypothermia": 1.35,
        "Inspiration": 1.30,
        "Trinity": 1.40,
    }
    
    for key, mult in multipliers.items():
        if key.lower() in gem_name.lower():
            # æ ¹æ“šç­‰ç´šå°å¹…èª¿æ•´
            level_bonus = 1 + (gem_level - 1) * 0.004
            return mult * level_bonus
    
    # é è¨­è¼”åŠ©å¯¶çŸ³
    return 1.24  # 24% more damage


def is_support_gem(gem_name: str) -> bool:
    """åˆ¤æ–·æ˜¯å¦ç‚ºè¼”åŠ©å¯¶çŸ³"""
    support_keywords = [
        "Support", "support", "Awakened", "awakened",
        "Damage on Full Life", "Elemental Damage with Attacks",
        "Added Cold", "Added Fire", "Added Lightning",
        "Increased Critical", "Hypothermia", "Inspiration",
        "Vicious Projectiles", "Multistrike", "Melee Physical",
        "Fortify", "Concentrated Effect"
    ]
    return any(kw in gem_name for kw in support_keywords)


def extract_all_gems(root: ET.Element) -> List[Dict]:
    """æå–æ‰€æœ‰å¯¶çŸ³ï¼ˆå®Œæ•´è³‡è¨Šï¼‰"""
    all_gems = []
    skills_elem = root.find("Skills")
    
    if not skills_elem:
        return all_gems
    
    for skill_set in skills_elem.findall("SkillSet"):
        for skill in skill_set.findall("Skill"):
            skill_data = {
                "label": skill.get("label", "Unknown"),
                "enabled": skill.get("enabled", "true") == "true",
                "slot": skill.get("slot", ""),
                "gems": []
            }
            
            for gem in skill.findall("Gem"):
                gem_data = {
                    "name": gem.get("nameSpec", "Unknown"),
                    "level": int(gem.get("level", 1)),
                    "quality": int(gem.get("quality", 0)),
                    "enabled": gem.get("enabled", "true") == "true",
                    "is_support": is_support_gem(gem.get("nameSpec", ""))
                }
                skill_data["gems"].append(gem_data)
            
            all_gems.append(skill_data)
    
    return all_gems


def extract_equipment(root: ET.Element) -> Dict[str, Any]:
    """æå–è£å‚™è³‡è¨Š"""
    items = {}
    items_elem = root.find("Items")
    
    if not items_elem:
        return items
    
    slots = {
        "Weapon 1": "mainhand",
        "Weapon 2": "offhand",
        "Helmet": "helmet",
        "Body Armour": "body",
        "Gloves": "gloves",
        "Boots": "boots",
        "Amulet": "amulet",
        "Ring 1": "ring1",
        "Ring 2": "ring2",
        "Belt": "belt"
    }
    
    for item_set in items_elem.findall("ItemSet"):
        for slot_name, slot_key in slots.items():
            slot_elem = item_set.find(f"Slot[@name='{slot_name}']")
            if slot_elem is not None:
                item = slot_elem.find("Item")
                if item is not None:
                    items[slot_key] = {
                        "name": item.get("name", "Empty"),
                        "rarity": item.get("rarity", "NORMAL"),
                        "text": item.text if item.text else ""
                    }
    
    return items


def extract_passive_tree(root: ET.Element) -> Dict[str, Any]:
    """æå–å¤©è³¦æ¨¹é…ç½®"""
    tree_elem = root.find("Tree")
    if not tree_elem:
        return {"nodes": [], "total": 0, "url": ""}
    
    spec_elem = tree_elem.find("Spec")
    if not spec_elem:
        return {"nodes": [], "total": 0, "url": ""}
    
    url_elem = spec_elem.find("URL")
    url = url_elem.text if url_elem is not None else ""
    
    # è§£æç¯€é» IDï¼ˆå¾ URL æˆ– Node æ¨™ç±¤ï¼‰
    nodes = []
    for node in spec_elem.findall("Node"):
        node_id = node.get("nodeId")
        if node_id:
            nodes.append(int(node_id))
    
    return {
        "nodes": nodes,
        "total": len(nodes),
        "url": url
    }