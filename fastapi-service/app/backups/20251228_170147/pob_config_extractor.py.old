"""
PoB é…ç½®æå–å™¨ï¼ˆç²¾ç°¡ç‰ˆï¼‰
å°ˆæ³¨æ–¼æå– 100% æº–ç¢ºçš„é…ç½®è³‡è¨Š
ä¸è¨ˆç®— DPS æˆ–ç”Ÿå‘½å€¼ï¼Œç”±ç”¨æˆ¶åœ¨ PoB ä¸­é©—è­‰
"""
import xml.etree.ElementTree as ET
from typing import Dict, Any, List
import logging

logger = logging.getLogger(__name__)


def extract_build_configuration(root: ET.Element) -> Dict[str, Any]:
    """
    æå–å»ºæ§‹é…ç½®ï¼ˆä¸è¨ˆç®—æ•¸å€¼ï¼‰
    è¿”å›ï¼šè§’è‰²è³‡è¨Šã€æŠ€èƒ½é…ç½®ã€è£å‚™é…ç½®ã€å¤©è³¦æ¨¹
    """
    result = {
        "character_info": extract_character_info(root),
        "skill_configuration": extract_skill_configuration(root),
        "equipment_configuration": extract_equipment_configuration(root),
        "passive_tree": extract_passive_tree(root),
        "config_options": extract_config_options(root)
    }
    
    logger.info(f"âœ… é…ç½®æå–å®Œæˆ: {result['character_info']['class']} Lv{result['character_info']['level']}")
    
    return result


def extract_character_info(root: ET.Element) -> Dict[str, Any]:
    """æå–è§’è‰²åŸºæœ¬è³‡è¨Š"""
    build_elem = root.find("Build")
    
    if not build_elem:
        return {
            "level": 1,
            "class": "Unknown",
            "ascendancy": None,
            "league": "Standard"
        }
    
    return {
        "level": int(build_elem.get("level", 1)),
        "class": build_elem.get("className", "Unknown"),
        "ascendancy": build_elem.get("ascendClassName", None),
        "league": build_elem.get("league", "Standard"),
        "main_socket_group": int(build_elem.get("mainSocketGroup", 1))
    }


def extract_skill_configuration(root: ET.Element) -> List[Dict[str, Any]]:
    """
    æå–æŠ€èƒ½é…ç½®ï¼ˆå®Œæ•´ä¸”æº–ç¢ºï¼‰
    åŒ…æ‹¬ï¼šå¯¶çŸ³åç¨±ã€ç­‰ç´šã€å“è³ªã€æ˜¯å¦å•Ÿç”¨ã€æ’æ§½ä½ç½®
    """
    skills = []
    skills_elem = root.find("Skills")
    
    if not skills_elem:
        return skills
    
    for skill_set in skills_elem.findall("SkillSet"):
        for skill in skill_set.findall("Skill"):
            enabled = skill.get("enabled", "true") == "true"
            
            skill_data = {
                "label": skill.get("label", "Unknown"),
                "enabled": enabled,
                "slot": skill.get("slot", ""),
                "main_active_skill": skill.get("mainActiveSkill"),
                "gems": []
            }
            
            # æå–æ‰€æœ‰å¯¶çŸ³è³‡è¨Š
            for gem in skill.findall("Gem"):
                gem_name = gem.get("nameSpec", "Unknown")
                
                gem_data = {
                    "name": gem_name,
                    "level": int(gem.get("level", 1)),
                    "quality": int(gem.get("quality", 0)),
                    "enabled": gem.get("enabled", "true") == "true",
                    "is_support": is_support_gem(gem_name),
                    "is_awakened": "Awakened" in gem_name,
                    "quality_type": gem.get("qualityId", "Default")
                }
                
                skill_data["gems"].append(gem_data)
            
            # åªä¿ç•™å•Ÿç”¨ä¸”æœ‰å¯¶çŸ³çš„æŠ€èƒ½çµ„
            if enabled and skill_data["gems"]:
                skills.append(skill_data)
    
    logger.info(f"ğŸ“Š æ‰¾åˆ° {len(skills)} å€‹æŠ€èƒ½é…ç½®")
    return skills


def extract_equipment_configuration(root: ET.Element) -> Dict[str, Dict]:
    """
    æå–è£å‚™é…ç½®ï¼ˆè©ç¶´è³‡è¨Šï¼‰
    ä¸è¨ˆç®—æ•¸å€¼ï¼Œåªæå–è©ç¶´æ–‡å­—
    """
    equipment = {}
    items_elem = root.find("Items")
    
    if not items_elem:
        return equipment
    
    slot_mapping = {
        "Weapon 1": "mainhand",
        "Weapon 2": "offhand",
        "Helmet": "helmet",
        "Body Armour": "body",
        "Gloves": "gloves",
        "Boots": "boots",
        "Amulet": "amulet",
        "Ring 1": "ring1",
        "Ring 2": "ring2",
        "Belt": "belt",
        "Flask 1": "flask1",
        "Flask 2": "flask2",
        "Flask 3": "flask3",
        "Flask 4": "flask4",
        "Flask 5": "flask5"
    }
    
    for item_set in items_elem.findall("ItemSet"):
        for slot_name, slot_key in slot_mapping.items():
            slot_elem = item_set.find(f"Slot[@name='{slot_name}']")
            
            if slot_elem is not None:
                item_elem = slot_elem.find("Item")
                
                if item_elem is not None:
                    equipment[slot_key] = parse_item_details(item_elem)
    
    logger.info(f"ğŸ’ æ‰¾åˆ° {len(equipment)} ä»¶è£å‚™")
    return equipment


def parse_item_details(item_elem: ET.Element) -> Dict[str, Any]:
    """è§£æå–®ä»¶è£å‚™çš„è©³ç´°è³‡è¨Š"""
    item_text = item_elem.text if item_elem.text else ""
    
    # è§£æåŸºæœ¬è³‡è¨Š
    item_data = {
        "name": item_elem.get("name", ""),
        "rarity": item_elem.get("rarity", "NORMAL"),
        "item_level": int(item_elem.get("itemLevel", 0)),
        "type_line": "",
        "implicit_mods": [],
        "explicit_mods": [],
        "crafted_mods": [],
        "fractured_mods": [],
        "sockets": []
    }
    
    # è§£æè©ç¶´ï¼ˆå¾ç‰©å“æ–‡å­—ä¸­æå–ï¼‰
    if item_text:
        lines = item_text.strip().split('\n')
        current_section = None
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            # è­˜åˆ¥ä¸åŒé¡å‹çš„è©ç¶´
            if "Rarity:" in line:
                continue
            elif "{crafted}" in line:
                item_data["crafted_mods"].append(line.replace("{crafted}", "").strip())
            elif "{fractured}" in line:
                item_data["fractured_mods"].append(line.replace("{fractured}", "").strip())
            else:
                # æ ¹æ“šä½ç½®åˆ¤æ–·æ˜¯å›ºæœ‰è©ç¶´é‚„æ˜¯æ˜æ–‡è©ç¶´
                if not item_data["implicit_mods"] and "--------" not in line:
                    item_data["implicit_mods"].append(line)
                elif "--------" not in line:
                    item_data["explicit_mods"].append(line)
    
    # è§£ææ’æ§½
    sockets = item_elem.get("sockets", "")
    if sockets:
        item_data["sockets"] = parse_sockets(sockets)
    
    return item_data


def parse_sockets(socket_string: str) -> List[Dict[str, str]]:
    """è§£ææ’æ§½é…ç½®"""
    sockets = []
    
    if not socket_string:
        return sockets
    
    # æ ¼å¼: "R-R-R G-G-G" (é€£çµç”¨ - åˆ†éš”ï¼Œçµ„åˆ¥ç”¨ç©ºæ ¼åˆ†éš”)
    groups = socket_string.split(' ')
    
    for group in groups:
        colors = group.split('-')
        for color in colors:
            sockets.append({
                "color": color,
                "group": groups.index(group)
            })
    
    return sockets


def extract_passive_tree(root: ET.Element) -> Dict[str, Any]:
    """æå–å¤©è³¦æ¨¹é…ç½®"""
    tree_elem = root.find("Tree")
    
    if not tree_elem:
        logger.warning("âš ï¸ æ‰¾ä¸åˆ° Tree å…ƒç´ ")
        return {"nodes": [], "total": 0, "url": ""}
    
    spec_elem = tree_elem.find("Spec")
    
    if not spec_elem:
        logger.warning("âš ï¸ æ‰¾ä¸åˆ° Spec å…ƒç´ ")
        return {"nodes": [], "total": 0, "url": ""}
    
    # ğŸ”§ æ–¹æ³• 1: å¾ Node æ¨™ç±¤æå–ç¯€é»
    allocated_nodes = []
    for node_elem in spec_elem.findall("Node"):
        node_id = node_elem.get("nodeId")
        if node_id:
            try:
                allocated_nodes.append(int(node_id))
            except ValueError:
                continue
    
    # ğŸ”§ æ–¹æ³• 2: å¦‚æœæ–¹æ³• 1 å¤±æ•—ï¼Œå˜—è©¦å¾ URL æå–
    url_elem = spec_elem.find("URL")
    url = url_elem.text if url_elem is not None and url_elem.text else ""
    
    if not allocated_nodes and url:
        logger.info("ğŸ” å˜—è©¦å¾ URL æå–å¤©è³¦æ¨¹ç¯€é»...")
        # URL æ ¼å¼: https://www.pathofexile.com/passive-skill-tree/AAAABgIBAG...
        # Base64 ç·¨ç¢¼çš„å¤©è³¦æ¨¹è³‡æ–™åœ¨ URL æœ€å¾Œ
        try:
            # ç°¡å–®æå–ï¼šPoB URL é€šå¸¸å¾ˆé•·ï¼Œèªªæ˜æœ‰å¤©è³¦æ¨¹è³‡æ–™
            # ä½†è§£æéœ€è¦é¡å¤–é‚è¼¯ï¼Œé€™è£¡å…ˆæ¨™è¨˜ç‚ºæœ‰å¤©è³¦æ¨¹
            if len(url) > 100:
                logger.info(f"âœ… å¤©è³¦æ¨¹è³‡æ–™å­˜åœ¨æ–¼ URL ä¸­ï¼ˆé•·åº¦: {len(url)}ï¼‰")
                # è¿”å› URLï¼Œå‰ç«¯å¯ä»¥é¡¯ç¤ºæç¤º
                return {
                    "nodes": [],
                    "total": 0,
                    "url": url,
                    "class_start": spec_elem.get("classId", "0"),
                    "note": "å¤©è³¦æ¨¹è³‡æ–™å­˜åœ¨æ–¼ URL ä¸­ï¼Œè«‹åœ¨ PoB æŸ¥çœ‹"
                }
        except Exception as e:
            logger.warning(f"âš ï¸ URL è§£æå¤±æ•—: {str(e)}")
    
    # ğŸ”§ æ–¹æ³• 3: æª¢æŸ¥æ˜¯å¦æœ‰ treeVersion å±¬æ€§ï¼ˆè¡¨ç¤ºæœ‰å¤©è³¦æ¨¹ï¼‰
    tree_version = spec_elem.get("treeVersion")
    if tree_version and not allocated_nodes:
        logger.info(f"âœ… æª¢æ¸¬åˆ°å¤©è³¦æ¨¹ç‰ˆæœ¬: {tree_version}ï¼Œä½†ç¯€é»è³‡æ–™åœ¨ URL ä¸­")
        return {
            "nodes": [],
            "total": 0,
            "url": url,
            "class_start": spec_elem.get("classId", "0"),
            "tree_version": tree_version,
            "note": "å¤©è³¦æ¨¹è³‡æ–™å­˜åœ¨ï¼Œè«‹åœ¨ PoB æŸ¥çœ‹è©³ç´°ç¯€é»"
        }
    
    logger.info(f"ğŸŒ² å¤©è³¦æ¨¹: {len(allocated_nodes)} å€‹ç¯€é»")
    
    return {
        "nodes": allocated_nodes,
        "total": len(allocated_nodes),
        "url": url,
        "class_start": spec_elem.get("classId", "0")
    }


def extract_config_options(root: ET.Element) -> Dict[str, str]:
    """æå–é…ç½®é¸é …ï¼ˆå¦‚ Flasksã€Charges ç­‰ï¼‰"""
    config = {}
    config_elem = root.find("Config")
    
    if not config_elem:
        return config
    
    for input_elem in config_elem.findall("Input"):
        name = input_elem.get("name", "")
        value = input_elem.text
        
        if name and value:
            config[name] = value
    
    return config


def is_support_gem(gem_name: str) -> bool:
    """åˆ¤æ–·æ˜¯å¦ç‚ºè¼”åŠ©å¯¶çŸ³"""
    support_keywords = [
        "Support", "support",
        "Awakened", "awakened",
        "Damage on Full Life",
        "Elemental Damage with Attacks",
        "Added Cold", "Added Fire", "Added Lightning",
        "Increased Critical", "Increased Duration",
        "Hypothermia", "Inspiration",
        "Vicious Projectiles", "Multistrike",
        "Melee Physical", "Fortify",
        "Concentrated Effect", "Increased Area",
        "Trinity", "Brutality",
        "Faster Attacks", "Faster Casting",
        "Spell Echo", "Greater Multiple Projectiles",
        "Lesser Multiple Projectiles"
    ]
    
    return any(keyword in gem_name for keyword in support_keywords)


def identify_main_skill(skills: List[Dict]) -> Dict[str, Any]:
    """è­˜åˆ¥ä¸»æŠ€èƒ½çµ„"""
    # å°‹æ‰¾å•Ÿç”¨ä¸”é€£çµæ•¸æœ€å¤šçš„æŠ€èƒ½çµ„
    main_skill = None
    max_links = 0
    
    for skill in skills:
        if not skill["enabled"]:
            continue
        
        link_count = len(skill["gems"])
        
        # å„ªå…ˆé¸æ“‡ 6L
        if link_count >= 5 and link_count > max_links:
            # ç¢ºèªæœ‰ä¸»å‹•æŠ€èƒ½å¯¶çŸ³
            has_active = any(not gem["is_support"] for gem in skill["gems"])
            if has_active:
                main_skill = skill
                max_links = link_count
    
    return main_skill or (skills[0] if skills else None)


# ============== é…ç½®æ¯”å°å‡½æ•¸ ==============

def compare_skill_configurations(player_skills: List[Dict], target_skills: List[Dict]) -> Dict[str, Any]:
    """
    æ¯”å°æŠ€èƒ½é…ç½®å·®ç•°
    100% æº–ç¢ºï¼Œå› ç‚ºåªæ¯”å°é…ç½®ï¼Œä¸è¨ˆç®—æ•¸å€¼
    """
    # è­˜åˆ¥ä¸»æŠ€èƒ½
    player_main = identify_main_skill(player_skills)
    target_main = identify_main_skill(target_skills)
    
    if not player_main or not target_main:
        return {"differences": [], "main_skill_match": False}
    
    differences = []
    
    # æ¯”å°ä¸»æŠ€èƒ½å¯¶çŸ³
    player_active = [g for g in player_main["gems"] if not g["is_support"]]
    target_active = [g for g in target_main["gems"] if not g["is_support"]]
    
    if player_active and target_active:
        if player_active[0]["name"] != target_active[0]["name"]:
            differences.append({
                "type": "different_main_skill",
                "priority": "critical",
                "player": player_active[0]["name"],
                "target": target_active[0]["name"],
                "message": f"ä¸»æŠ€èƒ½ä¸åŒï¼š{player_active[0]['name']} vs {target_active[0]['name']}"
            })
    
    # æ¯”å°å¯¶çŸ³ç­‰ç´š
    if player_active and target_active:
        level_diff = target_active[0]["level"] - player_active[0]["level"]
        if level_diff > 0:
            differences.append({
                "type": "gem_level",
                "priority": "high",
                "gem": player_active[0]["name"],
                "current": player_active[0]["level"],
                "target": target_active[0]["level"],
                "message": f"ä¸»æŠ€èƒ½ç­‰ç´šéœ€æå‡ {level_diff} ç´š (Lv{player_active[0]['level']} â†’ Lv{target_active[0]['level']})"
            })
    
    # æ¯”å°å¯¶çŸ³å“è³ª
    if player_active and target_active:
        quality_diff = target_active[0]["quality"] - player_active[0]["quality"]
        if quality_diff > 0:
            differences.append({
                "type": "gem_quality",
                "priority": "medium",
                "gem": player_active[0]["name"],
                "current": player_active[0]["quality"],
                "target": target_active[0]["quality"],
                "message": f"ä¸»æŠ€èƒ½å“è³ªéœ€æå‡ {quality_diff}% ({player_active[0]['quality']}% â†’ {target_active[0]['quality']}%)"
            })
    
    # æ¯”å°è¼”åŠ©å¯¶çŸ³
    player_supports = {g["name"]: g for g in player_main["gems"] if g["is_support"]}
    target_supports = {g["name"]: g for g in target_main["gems"] if g["is_support"]}
    
    # ç¼ºå°‘çš„è¼”åŠ©å¯¶çŸ³
    missing_supports = set(target_supports.keys()) - set(player_supports.keys())
    for support_name in missing_supports:
        target_gem = target_supports[support_name]
        differences.append({
            "type": "missing_support",
            "priority": "high" if target_gem["is_awakened"] else "medium",
            "gem": support_name,
            "target_level": target_gem["level"],
            "is_awakened": target_gem["is_awakened"],
            "message": f"ç¼ºå°‘è¼”åŠ©å¯¶çŸ³ï¼š{support_name} (Lv{target_gem['level']})"
        })
    
    # è¼”åŠ©å¯¶çŸ³ç­‰ç´šå·®ç•°
    for support_name in set(player_supports.keys()) & set(target_supports.keys()):
        player_gem = player_supports[support_name]
        target_gem = target_supports[support_name]
        
        level_diff = target_gem["level"] - player_gem["level"]
        if level_diff > 0:
            differences.append({
                "type": "support_level",
                "priority": "medium",
                "gem": support_name,
                "current": player_gem["level"],
                "target": target_gem["level"],
                "message": f"{support_name} éœ€å‡ç´š {level_diff} ç´š"
            })
    
    # æ¯”å°é€£çµæ•¸
    player_links = len(player_main["gems"])
    target_links = len(target_main["gems"])
    
    if player_links < target_links:
        differences.append({
            "type": "insufficient_links",
            "priority": "critical",
            "current": player_links,
            "target": target_links,
            "message": f"é€£çµæ•¸ä¸è¶³ï¼š{player_links}L â†’ éœ€è¦ {target_links}L"
        })
    
    return {
        "differences": differences,
        "main_skill_match": player_active[0]["name"] == target_active[0]["name"] if player_active and target_active else False,
        "player_main_skill": player_main,
        "target_main_skill": target_main
    }


def compare_passive_trees(player_nodes: List[int], target_nodes: List[int]) -> Dict[str, Any]:
    """
    æ¯”å°å¤©è³¦æ¨¹é…ç½®
    100% æº–ç¢º
    """
    player_set = set(player_nodes)
    target_set = set(target_nodes)
    
    missing_nodes = list(target_set - player_set)
    extra_nodes = list(player_set - target_set)
    common_nodes = list(player_set & target_set)
    
    match_rate = (len(common_nodes) / len(target_set) * 100) if target_set else 100
    
    return {
        "missing_nodes": missing_nodes,
        "missing_count": len(missing_nodes),
        "extra_nodes": extra_nodes,
        "extra_count": len(extra_nodes),
        "common_nodes": common_nodes,
        "match_rate": round(match_rate, 1),
        "points_needed": len(missing_nodes)
    }


def compare_equipment(player_eq: Dict, target_eq: Dict) -> List[Dict]:
    """
    æ¯”å°è£å‚™é…ç½®ï¼ˆè©ç¶´å±¤é¢ï¼‰
    æä¾›è£å‚™æ”¹é€²å»ºè­°
    """
    suggestions = []
    
    for slot in ["mainhand", "offhand", "helmet", "body", "gloves", "boots", "amulet", "ring1", "ring2", "belt"]:
        player_item = player_eq.get(slot)
        target_item = target_eq.get(slot)
        
        if not target_item:
            continue
        
        if not player_item:
            suggestions.append({
                "slot": slot,
                "type": "missing_item",
                "priority": "high",
                "message": f"{slot} ä½ç½®ç¼ºå°‘è£å‚™"
            })
            continue
        
        # æ¯”å°ç¨€æœ‰åº¦
        if player_item["rarity"] != target_item["rarity"]:
            suggestions.append({
                "slot": slot,
                "type": "rarity_mismatch",
                "priority": "medium",
                "player_rarity": player_item["rarity"],
                "target_rarity": target_item["rarity"],
                "message": f"{slot}: {player_item['rarity']} â†’ éœ€è¦ {target_item['rarity']}"
            })
        
        # æ¯”å°é—œéµè©ç¶´ï¼ˆç°¡åŒ–ç‰ˆï¼‰
        target_mod_keywords = extract_mod_keywords(target_item["explicit_mods"])
        player_mod_keywords = extract_mod_keywords(player_item["explicit_mods"])
        
        missing_keywords = target_mod_keywords - player_mod_keywords
        
        if missing_keywords:
            suggestions.append({
                "slot": slot,
                "type": "missing_mods",
                "priority": "medium",
                "missing_keywords": list(missing_keywords),
                "message": f"{slot} ç¼ºå°‘é—œéµè©ç¶´ï¼š{', '.join(missing_keywords)}"
            })
    
    return suggestions


def extract_mod_keywords(mods: List[str]) -> set:
    """å¾è©ç¶´ä¸­æå–é—œéµå­—"""
    keywords = set()
    
    important_keywords = [
        "Life", "Energy Shield", "Mana",
        "+# to Level of", "+# to Level of all",
        "Increased Damage", "Critical Strike",
        "Attack Speed", "Cast Speed",
        "Resistance", "Elemental Resistance",
        "Chaos Resistance",
        "Added Physical Damage", "Added Cold Damage",
        "Added Fire Damage", "Added Lightning Damage"
    ]
    
    for mod in mods:
        for keyword in important_keywords:
            if keyword.lower() in mod.lower():
                keywords.add(keyword)
    
    return keywords